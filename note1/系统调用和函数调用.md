## 系统调用
+ 操作系统服务的编程接口
+ 通常由高级语言编写（C 或 C++)
+ 程序访问通常是通过高层次的API接口而不是直接进行系统调用 ：  
系统调用一般被封装到库里，如标准 C 库，应用程序通过访问库函数（**函数调用**）来实现访问**系统调用**，如 printf（）到 write（）
+ 三种常见的应用程序编程接口（API）(用户用到的）
  + win32 API 用于 Windows
  + POSIX API 用于 POSIX-based systems（包括 UNIX,LINUX,Mac OS X 的所有版本）
  + Java API 用于 JAVA虚拟机（JVM)
## 函数调用和系统调用的不同处
1. 系统调用
  + INT 和 IRET 指令用于系统调用  
  系统调用时，堆栈切换和特权级的转换
2. 函数调用
  + CALL 和 RET 用于常规调用  
  常规调用时没有堆栈切换
  函数调用时有自己的堆栈储存参数，当使用到系统调用时，为了安全性，操作系统内核要进行**堆栈切换**，使用自己的堆栈进行处理，同时
  因为处于**内核态**，能使用**特权级指令**，对设备进行直接控制
## 中断、异常和系统调用的开销
+ 开销：（大于函数调用）
  + 引导机制
  + 建立内核堆栈
  + 验证参数（有效性和合法性需要验证）
  + 内核态映射到用户态的地址空间（更新页面映射权限，访问用户态的一些信息）
  + 内核态独立地址空间（TLB)  
  以上导致在用户态向内核态切换的系统调用开销大于函数调用
